1. In Objective-C, a class is itself an object with an opaque type called Class. Classes can’t have properties defined using the declaration syntax shown earlier for instances, but they can receive messages.

2. The typical use for a class method is as a factory method.

-------- Working with Objects ------------
Address: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithObjects/WorkingwithObjects.html

1. NSLog() uses format specifiers to indicate substitution tokens, just like the C standard library printf() function.

2. The substitution token %@ used to denote an object.  At runtime, this specifier will be substituted with the result of calling either the descriptionWithLocale: method (if it exists) or the description method on the provided object. The description method is implemented by NSObject to return the class and memory address of the object, but many Cocoa and Cocoa Touch classes override it to provide more useful information. In the case of NSString, the description method simply returns the string of characters that it represents.

3. There are some memory management considerations in this situation: a returned object (created on the heap) needs to exist long enough for it to be used by the original caller of the method, but not in perpetuity because that would create a memory leak. For the most part, the Automatic Reference Counting (ARC) feature of the Objective-C compiler takes care of these considerations for you.

4. Whenever you’re writing a method implementation, you have access to an important hidden value, self.

5. There’s another important keyword available to you in Objective-C, called super.

6. Note: It’s possible for init to return a different object than was created by alloc, so it’s best practice to nest the calls as shown.

7. Never initialize an object without reassigning any pointer to that object. As     an example, don’t do this:
      NSObject *someObject = [NSObject alloc];
      [someObject init];
   If the call to init returns some other object, you’ll be left with a pointer      to the object that was originally allocated but never initialized.

8. Use new to Create an Object If No Arguments Are Needed for Initialization
  It’s also possible to create an instance of a class using the new class method.   This method is provided by NSObject and doesn’t need to be overridden in your     own subclasses.

  It’s effectively the same as calling alloc and init with no arguments:

    XYZObject *object = [XYZObject new];
    // is effectively the same as:
    XYZObject *object = [[XYZObject alloc] init];

9. Because of Objective-C’s dynamic nature, it doesn’t matter what specific class type you use for that pointer—the correct method will always be called on the relevant object when you send it a message.

10.Note: If you expect a return value from a message sent to nil, the return value will be nil for object return types, 0 for numeric types, and NO for BOOL types. Returned structures have all members initialized to zero.

-------- Encapsulating Data ------------

1. ARC: Automatic Reference Counting

2. Strong reference cycles might lead to memory leaks.

3. Use Accessor method to Get/Set Property values.

4. The synthesized methods follow specific naming conventions:

The method used to access the value (the getter method) has the same name as the property.
The getter method for a property called firstName will also be called firstName.

The method used to set the value (the setter method) starts with the word “set” and then uses the capitalized property name.

The setter method for a property called firstName will be called setFirstName:.

5. it’s possible to add an attribute on the property:
   @property (getter=isFinished) BOOL finished;
   
6. When one object relies on other objects in this way, effectively taking ownership of those other objects, the first object is said to have strong references to the other objects. In Objective-C, an object is kept alive as long as it has at least one strong reference to it from another object.

7.Local variables (and non-property instance variables) also maintain strong references to objects by default. This means that the following code will work exactly as you expect:

    NSDate *originalDate = self.lastModificationDate;
    self.lastModificationDate = [NSDate date];
    NSLog(@"Last modification date changed from %@ to %@",
                        originalDate, self.lastModificationDate);
In this example, the local variable originalDate maintains a strong reference to the initial lastModificationDate object. When the lastModificationDate property is changed, the property no longer keeps a strong reference to the original date, but that date is still kept alive by the originalDate strong variable.

Note: A variable maintains a strong reference to an object only as long as that variable is in scope, or until it is reassigned to another object or nil.

8. because in a multi-threaded application, the property may be deallocated between the test and the method call, rendering the test useless. Instead, you need to declare a strong local variable to cache the value, like this:

    NSObject *cachedObject = self.someWeakProperty;           // 1
    if (cachedObject) {                                       // 2
        [someObject doSomethingImportantWith:cachedObject];   // 3
    }                                                         // 4
    cachedObject = nil;                                       // 5
	
9. In a factory method, we can call [[self alloc]init], then we can use the object function;

10. NSMutableString cannot initialized by literal String like @"John", it should be initialized as follow:
    NSMutableString *str = [NSMutableString stringWithString:@"John"];
	
-------------Ex 4--------------
1. init has to be object function instead of class function;
2. The error I have made is I used a third pointer to point to the object. Person.
3. Please see the code in Ex2 and Ex3 for the problem.
4. Try use the same test code in main with different init functions (EX2-3 and EX4), you will find where the problem is.



